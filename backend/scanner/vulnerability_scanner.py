import requests
from bs4 import BeautifulSoup
import urllib.parse
import time
import re
from typing import List, Dict

class VulnerabilityScanner:
    def __init__(self, target_url: str):
        self.target_url = target_url.rstrip('/')  # Remove trailing slash
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'VulnScan-Pro/1.0'
        })
        self.vulnerabilities = []
        
        # XSS payloads (fixed string escaping)
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "'><script>alert('XSS')</script>",
            '"><script>alert("XSS")</script>',
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//",
        ]
        
        # SQL injection payloads
        self.sql_payloads = [
            "'",
            "1' OR '1'='1",
            "1' OR '1'='1' --",
            "1' OR '1'='1' /*",
            "' OR 1=1--",
            "' UNION SELECT null--",
            "1; DROP TABLE users--",
            "' OR 'x'='x",
        ]

    def scan_web_vulnerabilities(self) -> List[Dict]:
        """Scan for web vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Ensure target URL has proper scheme
            if not self.target_url.startswith(('http://', 'https://')):
                # Try HTTPS first, then HTTP
                test_urls = [f'https://{self.target_url}', f'http://{self.target_url}']
                response = None
                
                for test_url in test_urls:
                    try:
                        response = self.session.get(test_url, timeout=10)
                        self.target_url = test_url
                        break
                    except requests.exceptions.RequestException:
                        continue
                
                if response is None:
                    return [{
                        'type': 'Connection Error',
                        'severity': 'High',
                        'title': 'Unable to connect to target',
                        'description': 'Could not connect via HTTP or HTTPS',
                        'url': self.target_url
                    }]
            else:
                # Get initial page
                response = self.session.get(self.target_url, timeout=10)
            
            if response.status_code != 200:
                return [{
                    'type': 'Connection Error',
                    'severity': 'High',
                    'title': 'Unable to connect to target',
                    'description': f'HTTP {response.status_code}: {response.reason}',
                    'url': self.target_url
                }]
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Check for XSS vulnerabilities
            xss_vulns = self._scan_xss(soup)
            vulnerabilities.extend(xss_vulns)
            
            # Check for SQL injection vulnerabilities
            sql_vulns = self._scan_sql_injection(soup)
            vulnerabilities.extend(sql_vulns)
            
            # Check security headers
            header_vulns = self._check_security_headers(response)
            vulnerabilities.extend(header_vulns)
            
            # Check for sensitive information disclosure
            info_vulns = self._check_information_disclosure(response.text)
            vulnerabilities.extend(info_vulns)
            
        except requests.exceptions.RequestException as e:
            vulnerabilities.append({
                'type': 'Network Error',
                'severity': 'High',
                'title': 'Network connection failed',
                'description': str(e),
                'url': self.target_url
            })
            
        return vulnerabilities

    def _scan_xss(self, soup: BeautifulSoup) -> List[Dict]:
        """Scan for XSS vulnerabilities"""
        vulnerabilities = []
        
        try:
            forms = soup.find_all('form')
            
            for form in forms:
                action = form.get('action', '')
                method = form.get('method', 'get').lower()
                
                # Get all input fields
                inputs = form.find_all(['input', 'textarea'])
                form_data = {}
                
                for input_field in inputs:
                    input_type = input_field.get('type', 'text')
                    input_name = input_field.get('name', '')
                    
                    if input_name and input_type not in ['submit', 'button', 'reset', 'file']:
                        form_data[input_name] = 'test'
                
                # Skip if no testable fields found
                if not form_data:
                    continue
                
                # Test each XSS payload
                for payload in self.xss_payloads:
                    test_data = form_data.copy()
                    
                    # Try payload in each field
                    for field_name in test_data.keys():
                        test_data[field_name] = payload
                        
                        try:
                            target_url = urllib.parse.urljoin(self.target_url, action) if action else self.target_url
                            
                            if method == 'post':
                                response = self.session.post(target_url, data=test_data, timeout=5)
                            else:
                                response = self.session.get(target_url, params=test_data, timeout=5)
                            
                            # Check if payload is reflected in response
                            if payload in response.text and response.status_code == 200:
                                vulnerabilities.append({
                                    'type': 'Cross-Site Scripting (XSS)',
                                    'severity': 'High',
                                    'title': f'XSS vulnerability in {field_name} parameter',
                                    'description': f'The parameter "{field_name}" is vulnerable to XSS attacks',
                                    'url': target_url,
                                    'payload': payload
                                })
                        
                        except requests.exceptions.RequestException:
                            continue
                        
                        # Reset field value
                        test_data[field_name] = 'test'
                        time.sleep(0.1)  # Small delay to avoid overwhelming server
        except Exception as e:
            # Log XSS scanning error but continue
            pass
        
        return vulnerabilities

    def _scan_sql_injection(self, soup: BeautifulSoup) -> List[Dict]:
        """Scan for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            forms = soup.find_all('form')
            
            for form in forms:
                action = form.get('action', '')
                method = form.get('method', 'get').lower()
                
                # Get all input fields
                inputs = form.find_all(['input', 'textarea'])
                form_data = {}
                
                for input_field in inputs:
                    input_type = input_field.get('type', 'text')
                    input_name = input_field.get('name', '')
                    
                    if input_name and input_type not in ['submit', 'button', 'reset', 'file']:
                        form_data[input_name] = 'test'
                
                # Skip if no testable fields found
                if not form_data:
                    continue
                
                # Test each SQL payload
                for payload in self.sql_payloads:
                    test_data = form_data.copy()
                    
                    # Try payload in each field
                    for field_name in test_data.keys():
                        test_data[field_name] = payload
                        
                        try:
                            target_url = urllib.parse.urljoin(self.target_url, action) if action else self.target_url
                            
                            if method == 'post':
                                response = self.session.post(target_url, data=test_data, timeout=5)
                            else:
                                response = self.session.get(target_url, params=test_data, timeout=5)
                            
                            # Check for SQL error indicators
                            sql_errors = [
                                'mysql_fetch_array()',
                                'ORA-01756',
                                'Microsoft OLE DB Provider for ODBC Drivers',
                                'PostgreSQL query failed',
                                'SQLite error',
                                'sqlite3.OperationalError',
                                'Warning: mysql_',
                                'valid MySQL result',
                                'MySqlClient.MySqlException',
                                'System.Data.OleDb.OleDbException',
                                'SQLServer JDBC Driver',
                                'syntax error',
                                'mysql_num_rows()',
                                'ORA-00933',
                                'SQL command not properly ended'
                            ]
                            
                            response_text_lower = response.text.lower()
                            for error in sql_errors:
                                if error.lower() in response_text_lower:
                                    vulnerabilities.append({
                                        'type': 'SQL Injection',
                                        'severity': 'Critical',
                                        'title': f'SQL Injection vulnerability in {field_name} parameter',
                                        'description': f'The parameter "{field_name}" appears to be vulnerable to SQL injection',
                                        'url': target_url,
                                        'payload': payload
                                    })
                                    break
                        
                        except requests.exceptions.RequestException:
                            continue
                        
                        # Reset field value
                        test_data[field_name] = 'test'
                        time.sleep(0.1)  # Small delay
        except Exception as e:
            # Log SQL scanning error but continue
            pass
        
        return vulnerabilities

    def _check_security_headers(self, response: requests.Response) -> List[Dict]:
        """Check for missing security headers"""
        vulnerabilities = []
        headers = response.headers
        
        security_headers = {
            'X-Content-Type-Options': {
                'severity': 'Medium',
                'description': 'Missing X-Content-Type-Options header can lead to MIME type sniffing attacks'
            },
            'X-Frame-Options': {
                'severity': 'Medium',
                'description': 'Missing X-Frame-Options header can lead to clickjacking attacks'
            },
            'X-XSS-Protection': {
                'severity': 'Low',
                'description': 'Missing X-XSS-Protection header reduces XSS protection'
            },
            'Strict-Transport-Security': {
                'severity': 'High',
                'description': 'Missing HSTS header allows downgrade attacks on HTTPS sites'
            },
            'Content-Security-Policy': {
                'severity': 'Medium',
                'description': 'Missing CSP header increases XSS attack surface'
            }
        }
        
        for header, info in security_headers.items():
            if header not in headers:
                vulnerabilities.append({
                    'type': 'Missing Security Header',
                    'severity': info['severity'],
                    'title': f'Missing {header} header',
                    'description': info['description'],
                    'url': self.target_url
                })
        
        return vulnerabilities

    def _check_information_disclosure(self, response_text: str) -> List[Dict]:
        """Check for sensitive information disclosure"""
        vulnerabilities = []
        
        # Patterns to check for sensitive information
        sensitive_patterns = {
            r'password\s*[:=]\s*["\'][^"\']*["\']': {
                'title': 'Password disclosure',
                'severity': 'Critical'
            },
            r'api[_-]?key\s*[:=]\s*["\'][^"\']*["\']': {
                'title': 'API key disclosure',
                'severity': 'High'
            },
            r'secret[_-]?key\s*[:=]\s*["\'][^"\']*["\']': {
                'title': 'Secret key disclosure',
                'severity': 'High'
            },
            r'mysql://[^:]+:[^@]+@[^/]+': {
                'title': 'Database connection string disclosure',
                'severity': 'Critical'
            },
            r'(?i)(error|exception|traceback|stack\s+trace)': {
                'title': 'Error message disclosure',
                'severity': 'Low'
            }
        }
        
        try:
            for pattern, info in sensitive_patterns.items():
                if re.search(pattern, response_text, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': info['severity'],
                        'title': info['title'],
                        'description': 'Sensitive information found in response',
                        'url': self.target_url
                    })
        except Exception as e:
            # Log pattern matching error but continue
            pass
        
        return vulnerabilities